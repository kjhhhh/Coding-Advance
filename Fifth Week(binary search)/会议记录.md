> - 第五周题解会议：二分查找
>   - 上周回顾：题解LeetCode347:李勃朝同学
>   - 题解LeetCode704:甘文光同学
>   - 题解LeetCode278:王成同学
>   - 题解LeetCode275:黄添洪同学
>   - 题解LeetCode240:颜勇君同学
>   - 题解LeetCode81:许雅婷同学
>   - 组长:匡俊桦同学
>   - 会议秘书:朱锟同学
>   - 点评:袁鑫攀老师
> - 时间：2023年7月8日 上午8点
> - 腾讯会议

---

- 会议开场
	- 二分查找
		- 是否满足二分查找的条件？有序序列？查找对象符合查找条件？
		- 二分查找中，如何根据target进行对半切分
		- 二分查找边界条件，全闭区间？左闭右开？左开右闭？不同取法得到的left，right是不一样的
	- 会议议程
		- 回顾上周通过堆这个数据结构得到topk，详细讲解堆这个数据结构，李勃朝同学讲解
		- 介绍本周题目以及讲题的同学：
			- 题解LeetCode704:甘文光同学，第一题是道经典的求位置二分查找题目，给你一个有序序列，要你找目标值在该序列中的位置
			- 题解LeetCode278:王成同学 ，这是一道区间二分查找题目，给你一个有序序列，查找右区间最左目标的位置
			- 题解LeetCode275:黄添洪同学 ，这道题也是区间二分查找题目，给你一个有序序列，查找符合要求右区间的元素数量
			- 题解LeetCode240:颜勇君同学 ，这道题是一个二维数组二分查找求位置问题 可以拆分为两个一维数组的二分查找的子问题，也可以把它拍平成为一个一维的序列来进行二分查找
			- 题解LeetCode81:许雅婷同学，这道题也是一个一维二分查找求位置问题，但是给定的序列已经经过了旋转操作，即序列已经给分成两个部分有序的序列，需要切分出来才可以进行二分查找操作
---
- 题解LeetCode347:李勃朝同学
	- 堆的相关定义
		- 给出完全二叉树的定义，并指出堆通常是可以被看成一棵完全二叉树的数组对象，满足某个节点的值总是不大于或不小于其孩子节点的值
		- 大根堆：一棵完全二叉树，满足任一节点都大于或等于其孩子节点。
		- 小根堆：一棵完全二叉树，满足任一节点都小于或等于其孩子节点。
	- 自建堆结构（大根堆为例）
		- 假设根节点的左右子树都是堆，但是根节点不满足堆的性质，可以通过一次向下调整来将其变成一个堆。
		- 先判定是否有左右孩子，如果有则将根节点与左右孩子中较大的那个节点交换位置，重复上述过程，直到满足大根堆的定义。
	- 实现堆排序
		- 建立堆；
		- 得到堆顶元素，为最大元素；
		- 去掉堆顶，将堆最后一个元素放到堆顶，此时可通过一次调整重新使堆有序；
		- 堆顶元素为第二大元素；
		- 重复步骤3，直到堆变空。
- 袁老师点评：
	- 先判断下标是否越界，然后再执行后面的程序
	- 建议两个函数分开演示，而不是全部演示，单元测试通过后再集成测试
	- 堆的数据结构很有用，topk只需要调k次，在特定应用场景时可只进行部分排序操作
---
- 题解LeetCode704:甘文光同学
	- 二分查找的定义，实现原理，对有序数组不断一分为二，取中间值与目标值进行比对，根据大小关系，选择一边继续一分为二，不断循环此操作，以此来找到目标值。
	- 二分查找示例，通过具体的数组展示实现的细节，
	  - 如果判定条件是right-left > 1，找到则直接返回，没找到则把中间值作为新的边界，跳出循环会得到两个元素的子数组，如果子数组中有元素等于目标值，则找到目标值，如果子数组中无元素等于目标值，则未找到。
	  - 如果判断条件是left<=right，不把中间值作为新的边界时，若找到，会在循环过程中返回，若没找到，则会跳出循环，返回-1
	- 不同的划分方式，判定条件不同
- 袁老师点评：
	- 讲的很好
	- 这道题使用递归解法反而会麻烦一些。因此有些题目使用递归会简单很多，而有些题目使用递归反而会变得麻烦。
---
- 题解LeetCode278:王成同学
	- 通过画图展现二分查找的过程
	- 函数判断，如果是错误版本，那么返回true
	- 防止溢值，不采用（right+left)//2 而采用left + (right - left)//2
	- 判定条件是left<right,如果中间值是错误版本，则第一个错误版本在[left,mid]中寻找，如果中间值不是错误版本，则在[left+1,right]中查找，当left等于right时，则只剩第一个错误版本
- 袁老师点评：
	- 一般的二分查找可以right = mid-1 ， 但本题为什么不能，要说出原因
	- 实力不够时，讲数据，以数据为核心为驱动去讲，例子中的数据再少，也是数据
	- 讲的时候列出一堆异常数据，比如10个用例来展现实现的过程
	- 你们没有真正开发项目的经历，只是写demo，并没考虑异常的数据，因此要通过leetcode执行例子得到反馈，调整代码
---
- 题解LeetCode275:黄添洪同学
	- `h` 指数是指`n` 篇论文中**总共**有 `h` 篇论文分别被引用了**至少** `h` 次。总共的意思是n篇论文中有h篇论文，每篇论文引用次数均大于或等于h次
	- 通过数据展示整个过程
	- 方法一：二分法
		- 题目的临界条件就是citations[mid]>=len-mid，符合条件就到左边查找下一个符合条件的，如果不符合条件就到右边找下一个符合条件的，跳出循环后len-1-right就是h指数
	- 方法二：遍历法
		- 首先将数组反转，从大到小排列，并设h的值初始化为0
		- 然后遍历数组，如果当前值也就是论文引用次数大于等于`i+1`(引用值大于等于当前篇数)，则`i+1`就是当前子数组的h值，遍历完整个数组，则返回整个数组的h值
- 袁老师点评：
	- 很精彩的分享
	- [::-1] -1表示步长，达到反转数组的作用
	- 理解的难点在，数组里面不一定有答案，比如[0,1,5,5,6,7]，h指数是4，并不在数组里面
	- 难度挺大的，不是简单的查找，边界的判定很难一步想透。
---
- 题解LeetCode240:颜勇君同学
	- 方法一：暴力算法
		- 两个循环遍历二维数组，判断是否有目标值，如果找到返回True，如果没找到返回False
	- 方法二：遍历+二分
		- 对每一行进行二分查找，这样减少遍历次数
	- 方法三：斜对角线二分查找
		- 方法二只用到了行有序这个规律，没有用到列有序的规律
		- 行指针指向第一行，列指针指向最后一列开始，将`nums[row][col]`与目标值比较，如果大于目标值，则该列均大于目标值，将该列舍弃，将列指针减1，如果`nums[row][col]`小于目标值，这说明该行均小于目标值，将该行舍弃，将行指针加1，如果找到目标值，则返回True，如果遍历完成均未找到则返回False
- 袁老师点评：
	- 方法三和方法二差别不大，方法三比方法二快一丢丢
	- 数据不全导致时间计算不同，更优的方法也可能时间更长
	- 递归方法实现，由李勃朝同学完成
---
- 题解LeetCode81:许雅婷同学
	- 审题
		- 不是完全有序的数组
		- 元素有可能重复
	- 方法一：遍历法
		- 遍历整个数组，直到找到目标值
	- 方法二：二分法
		- 已知数组部分有序，计算出中间下标，判断目标值是否等于中间值，等于，则返回True。
		- 我们发现将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的，通过左边界值与中间值比较，将数组分成一个有序数组、一个无序数组。判断目标值是否在有序数组数值范围中：
			- 1、目标值在有序数组的数值范围中，用二分查找寻找目标值，找到则返回True；否则，返回False。
			- 2、目标值不在有序数组的数值范围中，说明目标值可能在无序数组中，但此时已缩小了数组范围，继续划分操作。
		- 由于数组会出现重复值，如果出现特殊情况，比如左指针与右指针指向的值均等于中间值，则无法判断哪边是有序数组，因此将左指针加1，右指针减1，直到符合步骤二或退出循环
- 袁老师点评：
	- 讲的很好，通过多组数据展示整个过程
	- 只有一种情况，也就是右边界不可能超过左边界
	- 比赛的时候很难一下子写出这么多种情况的代码，得碰运气，但通过递归方法可能就不需要考虑那么多情况，在比赛中能够写得出。
	- 通过递归来实现，由匡俊桦同学研究
	- 画图的时候要掌握套路，通过箭头展示数据变化的趋势

---
