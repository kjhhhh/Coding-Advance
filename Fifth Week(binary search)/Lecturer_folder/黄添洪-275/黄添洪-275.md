题目大致意思：

给定一个不降数组序列（***有序***），在***O(logn)***的时间内找出最大的h指数，即序列中至少有h个元素不小于h。 





```
输入: citations = [0,1,3,5,6]
输出: 3
```

看看题目给出的示例  (题目的意思是"论文数要大于被引用数"**（i>=j）**）有 i 篇论文被至少引用了 j 次

|    序列     | i（有几篇论文） | j（被至少引用几次） |  h   |
| :---------: | :-------------: | :-----------------: | :--: |
| [0,1,3,5,6] |        5        |          0          |  0   |
|  [1,3,5,6]  |        4        |          1          |  1   |
|   [3,5,6]   |        3        |          3          |  3   |
|    [5,6]    |        2        |          5          |  2   |
|     [6]     |        1        |          6          |  1   |

### 第一种思路：遍历

为了表示方便，我们用 i 当做从后往前走的坐标，用 j 记录已经遍历过的论文数量(这里其实可以省去 j ，但为了方便说明，就分开啦)
①当 i >= j 的时候，对应前面的第1,2,3种情况。说明还可以继续往前走走看看
②当 i < j 的时候，对应前面第4,5种情况。说明不行啦！得结束啦

```
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        citations = citations[::-1] #将有序序列倒序，操作更方便 6 5 3 1 0
        length = len(citations)
        h = 0 #记录论文的数量
        for i in range(length):
            if citations[i] >= i+1:  #找到临界点
                h = i+1
        return h
```



| 时间复杂度 | 空间复杂度 |
| :--------: | :--------: |
|    O(n)    |    O(l)    |

### 第二种思路：二分法

综合有序和对数时间-----》使用二分查找



```
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        leng=len(citations)
        l=0
        r=leng-1
        while(l<=r):
            mid=(l+r)//2
            if(citations[mid]>=leng-mid):
                r=mid-1
            else:
                l=mid+1
        return leng-r-1
```



| 时间复杂度 | 空间复杂度 |
| :--------: | :--------: |
|  O(logn)   |    O(l)    |