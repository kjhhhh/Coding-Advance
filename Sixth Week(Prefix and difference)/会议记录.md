## 会议要求
- 可以提前确定时间，确定讲题同学
- 介绍本周主题，介绍题目要点，涉及知识点提起同学兴趣

## 开场白
- 各位同学们，老师们大家好！欢迎来到本周题解会议。我是本周的组长匡俊桦。
- 本次会议的主题是前缀和与差分，首先通过此次会议我们可以知道前缀和是一个什么定义，以及前缀和一般应用场景为求区间和的时候使用，区间和包括一维的子序列和以及二维的空间求和，而差分则与前缀和刚好相反，我们可以将差分想象成前缀和的逆运算，但是在实际应用中单独求某个差分数组的值很少，而是利用差分的思想，来解决子区间的和问题
## 本周讲题的同学
- [李勃朝同学]：[讲解240题] 首先是上周回顾 由李勃朝同学来介绍如何使用递归思路来解决如何在一个二维矩阵中搜索我们想要的target元素位置
- [匡俊桦同学]：[讲解81题] 之后由匡俊桦同学来进行介绍上周的在旋转数组中寻找target的递归解法
- [陈慧同学]：[讲解53题] 第一个由陈慧同学来介绍53题这道求最大连续子数组和问题，由于一些特殊情况，下周会议再讲解
- [营孟曦同学]：[讲解1991题] 第二个由营孟曦同学介绍1991题这道利用前缀和思想在数组中找到一个点可以将左右子数组和平均的点
- [金思铭同学]：[讲解560题] 第三个由金思铭同学来介绍560题，这道题是53题的变式，53题目只需要求连续子数组的和最大值，而这道题目需要求连续子数组和为k的子数组个数
- [袁鑫攀老师]：[讲解304题] 第四个由袁鑫攀老师来介绍304题，这道题为一维数组前缀和的升维题目，给你一个二维数组，要你求二维子区间和，即将一维前缀和思想应用到二维空间中
- [袁鑫攀老师]：[讲解363题] 最后一个由袁鑫攀老师来介绍363题，这道题也是一个二维前缀和问题，是53题目一维求解最大连续区间和的升维问题，要你在一个二维空间中求一个子区间的和不大于k的区域

---

- LeetCode240:李勃朝同学
	- 回顾题意，指出数组从左到右是升序的，从上到下也是升序的
	- 首先找到整个数组中间值与目标值比较，可以将数组分成两个部分，如果中间值小于目标值，那么可以不用考虑包括中间值在内的左上部分，如果中间值大于目标值，则中间值的右下部分均大于目标值，那么可以不用考虑中间值在内的右下部分。排除一部分后，将剩余部分切割并进行递归寻找，直到找到目标值。
- 袁老师点评
	- 不要想着切分那么精准，从筛选的角度出发
	- 直接过滤1/3左右，剪枝的思想
	- 代码继续调试，后面把代码提交github
---
- LeetCode81:匡俊桦同学
	- 回顾题意，确定重点，序列中值可能重复，旋转后的列表得到两个部分有序的列表
	- `nums[right]<=nums[left]`始终成立, mid左边有两种情况，一种是有序列表，一种是原始问题序列，右边同理，因此整个列表总共有四种情况
	- 对有序部分进行二分查找，对无序部分进行递归调用
	- 如果出现特殊情况，比如`Nums=[1,0,0,1,1,1,1]`, 由于`nums[right]=nums[mid]=nums[left]`, 把左右两边当作原始序列问题处理，则递归mid左半部分(包括mid)，递归mid右半部分。
	- 任何一边找到target就进行返回True，如果都没找到则返回False
	- 通过notebook展示过程，回顾方法一，遍历查找；方法二，二分查找；实现方法三，递归方法，实现再left，right，mid相同或不同时的处理方法
- 袁老师点评
	- 没问题，可读性好，更方便维护，代码很优美
	- 不要单纯比快慢，要比可读性
---
- LeetCode1991:营孟曦同学
	- 三种情况，中间值在中间，中间值在左边，中间值在右边
	- 指出查找成功和查找失败的例子
	- 方法一：暴力解法
		- 遍历数组，如果当前值的左半部分和右半部分相等则返回
	- 方法二：左右侧元素一起维护
		- 初始化左侧前缀和和为0，右侧前缀和为整个数组的和
		- 遍历数组时，右侧减去当前值，并与左侧前缀和比较，如果相等则直接返回索引，如果不相等则左侧前缀和加上当前元素，重复上述过程，直到找到中间值或不存在中间值
- 匡俊桦点评：
	- 有双指针的味道，左右两边向中间逼近
	- 这个思路很好，减少了一层循环，速度更快
---
- LeetCode560:金思铭同学
	- 读题，通过例子展示解题过程
	- 方法一：暴力解法
		- 两层循环，找到所有子数组的和，累计子数组中等于目标值的个数
	- 方法二：前缀和
		- 首先得到前缀和数组sumList，并在最前面增加元素0
		- 然后第一层循环遍历整个前缀和数组sumList，第二层循环查找后面前缀和减去第一层循环前缀和是否等于目标值，如果相等则总数加1，如果不相等则继续循环。
		- 基本思路是`后面前缀和-前面前缀和`，统计差值等于k的个数
	- 方法三：前缀和+哈希表
		- 将`后面前缀和-前面前缀和=k`转化为`后面前缀和-k=前面前缀和`
		- 遍历数组的过程中建立哈希表，首先得到前缀和，然后统计`前缀和-k`的个数，接着将前缀和放入字典，最后跳出循环，返回个数
- 袁老师点评
	- 讲得蛮好
	- 这个题很像两数之和，两个前缀和之差等于k
	- 先有思路，然后才有结构来承载他。
	- 要讲出关键的数据结构，为什么会想到字典，因为边遍历数组边建立哈希表可以减少一层循环
	- 命名修改一下，改成sumDict
	- dict.get(i,0)一样可以达到字典没有i元素时，赋初值为0
---
- LeetCode304:袁鑫攀老师
	- 前缀和，差分概念，前缀和看成积分，差分看成微分
	- 方法一：双重循环
		- 将row1,col1,row2,col2范围内所有元素累加
		- 大量数据时会超时
	- 方法二：二维数组前缀和
		- 拓宽上边界和左边界，最上面增加一行并全部置0，最左边增加一列并全部置0，方便使用推导公式
		- 二维矩阵的前缀和是以`在matrix[0][0]和matrix[i][j]所有元素的和`
		- 初始化二维矩阵前缀和，
			- 推导公式是`resmatrix[i][j] = resmatrix[i-1][j] + resmatrix[i][j-1] - resmatrix[i-1][j-1] + matrix[i-1][j-1]`
			- 大矩阵的前缀和是左边小矩阵前缀和`resmatrix[i][j-1]`加上边小矩阵前缀和`resmatrix[i-1][j]`减去公共部分`matrix[i-1][j-1]`，再加上二维矩阵当前位置`matrix[i-1][j-1]`的值
		- 使用二维矩阵前缀和
			- 返回以row1,col1,row2,col2为边界的二维数组的和，因为前缀和数组增加了一行，增加了一列，注意边界
			- 大矩阵的前缀和`resmatrix[row2+1][col2+1]`减去目标矩阵左边矩阵的前缀和`resmatrix[row2+1][col1]`，再减去目标矩阵上边矩阵的前缀和`resmatrix[row1][col2+1]`，再加上减了两次的公共部分`resmatrix[row1][col1]`
		- 具体原理看录屏
---
- LeetCode363:袁鑫攀老师
	- 如果是相等，那么使用hashmap，但这道题是不超过k，那么使用sortedset
	- sortedset.bisect_left(value)，返回大于等于value的第一个下标
	- 方法一：循环遍历
		- 通过四层循环，遍历所有的二维子数组并求和，得到不超过k 的最大值
	- 方法二：二维数组前缀和
		- 第一层循环，枚举上边界，第二层循环枚举下边界，将上下边界的所有列累加到一维数组，也就是将二维数组压缩成一维数组
		- 遍历一维数组的过程中，通过sortset中查找前缀和中是否存在满足条件的k‘，如果存在则更新最大值k'，接着将新的前缀和加入sortset中，直到遍历完当前一维数组。(k'=r-l, k'<= k, 则r-l<=k, 则l>=r-k, 需要在sortset中找大于或等于r-k的最小的值，满足 l >= r – k)
		- 例如`sortset([0,1,5,9,13,17])`，`如果r-k=8` , k是固定的，我们要找的k’是变化的，但要求k'<=k，k'由谁决定呢，由r-l，那么就必须l足够的大，侵占到k那边去，才能使得k'<=k，所以这里查表就应该返回9，13，17都可以，但又我们要找个最大的k'，所以在9，13，17里面选个最小的，就是9了。
		- 具体原理看录屏