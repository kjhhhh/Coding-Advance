> - 第四周题解会议：栈和队列
>   - 题解LeetCode20   :夏性权同学
>   - 题解LeetCode496:甘英华同学
>   - 题解LeetCode150:金思铭同学
>   - 题解LeetCode347:袁鑫攀老师
>   - 组长:匡俊桦同学
>   - 会议秘书:朱锟同学
>   - 点评:袁鑫攀老师
> - 时间：2023年7月1日 上午8点
>
> - 腾讯会议：512-417-516

- 要准备开场白
	- 本周主题
	- 选题思路
	- 讲者情况
---
- LeetCode20:夏性权同学
	- 方法一：用栈进行符号匹配
		- 读题发现符号匹配，想到数据结构中的栈
		- 讲解步骤，通过ppt动画展示符号匹配成功和匹配失败的过程
		- 代码讲解，遇到左括号进栈，遇到匹配的右括号就出栈，遇到不匹配的右括号则返回False，如果循环中遇到栈空着说明存在多余的右括号，如果循环过后发现栈不为空则说明有多余的左括号
		- 通过字典减少代码量，将`option = {'(':')' , '{':'}' , '[':']'}`存入字典中，则减少if-elif-else的判断，简化代码量
	- 方法二：左右括号相消
	  - 如果出现成对的括号，那么就替换成空字符串，循环过后，如果最终字符串为空，则匹配成功，如果最终字符串不为空，那么说明匹配失败
- 袁老师点评：
	- 讲得很好
	- 设计一个栈，如果左右可以匹配，那么就出栈，如果栈空或不匹配则直接返回False，最后栈里面还有元素，说明有多余左括号，返回False，如果没元素就说明符号完全匹配，返回True
	- 第二种方法比较取巧，利用了括号成对相消的特性
	- 掌握两个数据结构，字典，栈

---
- LeetCode496:甘英华同学
	- 读题，分析题目中的提示，通过ppt动画展示实现过程，通过notebook分析每一步的结果
	- 方法一：双循环遍历+字典
		- 定义ans数组，并使每个值为-1，如果发现下一个更大值则更新该位置，如果没有发现则保留原有值
		- 通过字典存储nums2，key为元素值，value为对应索引
		- 遍历nums1的过程中，到字典中查找该元素在num2中的下标，并从下标位置开始遍历num2，如果发现比该元素大的值就结束本层循环，放入ans列表中，如果没找到则不做处理，保留原来的值-1。
	- 方法二：递减栈+字典
		- 遍历nums2，通过递减栈发现nums2中每个元素的下一个更大元素，当栈不为空，且当前元素大于栈顶元素，则弹出栈顶元素作为key，将当前元素作为 value存入字典中，将当前元素加入栈中。如果当前元素不大于栈顶元素，那么直接将当前元素入栈。
		- 遍历num1，如果在字典中发现相同元素则将对应的value存入ans中，如果没有发现则存入-1
- 袁老师点评：
	- 讲得很好，很流畅，ppt还有动画，准备得很充分
	- 讲解过程有中间结果，使用了notebook的交互性
	- 提到了递减栈，最好把这个概念讲清楚

---
- LeetCode150:金思铭同学
	- 通过ppt演示整个过程，如果遇到数字就存入栈中，如果遇到运算符就将栈弹出两次，并进行运算，然后将运算结果存入栈中，直到栈中只有一个元素，得到最终结果
	- 遇到数字，入栈时将字符串类型转换为整型
	- 遇到运算符时，弹出栈顶元素存入second_number， 再次弹出栈顶元素存入first_number，将运算结果放入栈中
	- 通过字典方式存储运算符，简化代码，`{'+':add , '-':sub, '*':mul , '/':lambda x , y : x/float(y)}`
	  - from operator import add, sub, mul导包后才能使用add(),sub(),mul()
	  - 两个整数之间的除法总是向零截断，但是在python的 b / a 会向下取整
	  - 比如 正数部分：5 / 2 = 2;   负数部分：-1 / 132 = -1。
	  - 解决方法： int(b / float(a))
	- 最后弹出栈顶元素，得到最终结果
- 袁老师点评：
	- 先跑一遍，就算报错也要先展示出来
	- eval方法：
	  - eval()函数用于执行一个字符串表达式，并且返回该表达式的值[Python eval() 函数](https://blog.csdn.net/qq_42942881/article/details/109400343)
	  - eval(str(first_number)+optional+str(second_number))，eval函数中全部为字符串
---
- LeetCode347:袁老师
	- 方法一：排序法
	  - sorted()时间复杂度为O(nlogn)，如果元素特别多，k特别小，那么会造成性能浪费
	  -  [i for i,j in sorted(dic.items(),key = lambda x: x[1],reverse=True )[0:k] ]
	- 方法二：大根堆
	  - 大根堆的概念，ls[i] > ls[2*i+1] ls[i]>ls[2*i+2] , 小根堆的概念ls[i] < ls[2*i+1] ls[i]<ls[2*i+2]
	  - 采用大根堆，然后出堆k次，得到topk。由于heapq默认是小根堆，所以存入`(-1*value，key)`来构建大根堆
	    - ls = [(-1*j,i) for (i,j) in dic.items()] 预处理，方便构建大根堆
	    - heapq.heapify(ls)  heapify将ls转化为堆
	    - [Python中heapq库中函数的用法](https://blog.csdn.net/touxing777/article/details/124123061)
- 袁老师点评
	- 频率要想到字典`for num in nums:` `hashmap[num]=hashmap.get(num,0)+1`
	- 任意顺序-条件放宽，可以采用更多方法来解题
	- topk就要想到堆，要形成条件反射
	- 不要想着开外挂一样，直接写出最优的解法，而是先根据直觉，可能想出比较蠢的解法，出错了也要演示出来，因为能不断调整，不断优化，直到变成满意的解法
	- 要用notebook展现思考轨迹，每一步有什么样的效果，这样也符合科研的过程
	- 解题时涉及到的知识点应该讲清楚它的定义，它该如何用代码实现出来？又如何运用这个知识点解题
- 其他思路
	- 采用小根堆，如果超过k个元素时就弹出当前堆中最小值，始终保持堆中元素为k个，最后遍历整个堆，得到topk

