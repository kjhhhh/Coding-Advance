## 开场白
- 各位老师、同学大家好！
- 欢迎来到本周题解会议。我是本周的组长匡俊桦。
- 本次会议的主题是贪心算法，又名贪婪法，是寻找**最优解问题**的常用方法，这种方法模式一般将求解过程分成**若干个步骤**，但每个步骤都应用贪心原则，选取当前状态下**最好/最优的选择**（局部最有利的选择），并以此希望最后堆叠出的结果也是最好/最优的解。
## 贪心算法的基本要素(使用该算法的一般要求)：
- 贪心选择性质。
	- 所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。
	- 动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行，以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。(贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。)
	- 对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。
- 最优子结构
	- 当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。
	- 贪心算法其实并不能叫做算法，因为我们都知道算法需要有明确的输入输出，即当算法明确时，他的结构就已经明确了，但是贪心算法却不满足这一点，所以我们经常说的贪心其实是一种思想，那就是最优化思想。
## 接下来，我将为您介绍本周的题解者：
- [甘文光同学]：[讲解452题] 首先是由甘文光同学讲解这道区间贪心例题，与我们最初学习贪心时遇到的活动时间区间安排不同，这道区间例题更直接展示了贪心的本质，那就是局部最优达到全局最优的特点。
- [李勃朝同学]：[讲解376题] 第二个由李勃朝同学讲解这道最长子序列变化趋势问题，与一般的最长连续子序列问题不同，这道题不要求子序列连续，因此可以去除中间元素，使用贪心的思想进行处理。
- [匡俊桦同学]：[讲解968题] 第三个由匡俊桦同学讲解这道由二叉树的递归结构得到的原始递归解法和优化递归解法的贪心思路题目。
---
- LeetCode452射击最优化问题:甘文光同学  
	- 让气球尽可能的重叠，按照起始位置排序
	- 从前向后遍历气球数组，靠左尽可能让气球相交。
	- 如果气球直径有相交部分了，相交右边边界最小值之前的区间可以被同一只箭引爆，把最小值作为下一个气球的右边界。如果气球没重叠则新增一只箭
	- 总结
		- 注意
			- 只需要保证所有气球用最少的箭引爆，不需要考虑该气球被哪只箭射爆，局部最优可以保证最少箭数量
			- 满足 xstart ≤ x ≤ xend，说明两个气球只要间隔小于等于0就能被引爆
		- 将最少数量的箭引爆气球问题转换成找不重叠的区间问题
			- 1.按照区间起点，将所有的区间排序；
			- 2.只要找到区间起点大于前一个区间终点的区间，则当前区间就是不重叠的区间。
- 袁老师点评
	- 讲得很好，以后用实际数据再讲解会更好，通过更多的数据能够帮助我们更好的理解题目意思，也更加形象一些
	- `points[i][1] < points[i+1][0]`判定条件是小于而不是等于，是因为不相交就增加一只箭，相交就会同时引爆，不增加箭
	- 遍历数组过程中，存在相交时，更新下一个气球的右边界，与下次不相交时比较，很好的联动起来了。
---
- LeetCode376摆动序列最长子序列问题:李勃朝同学 
	- 方法一：有效差值数量
		- 遍历数组，过程中用different数组记录正负交替的差值
		- different数组长度加一为摆动序列的最长子序列的长度
		- 时间复杂度O(n)，空间复杂度O(n)
	- 优化方法一：统计变化次数
		- 遍历数组，过程中用different数组记录正负变化的次数
		- different的值加一为摆动序列的最长子序列的长度
		- 时间复杂度O(n)，空间复杂度O(1)
	- 方法二：统计峰谷个数
		- 1、某个序列被称为「上升摆动序列」，当且仅当该序列是摆动序列，且最后一个元素呈上升趋势。如序列 [1,3,2,4] 即为「上升摆动序列」。
		- 2、某个序列被称为「下降摆动序列」，当且仅当该序列是摆动序列，且最后一个元素呈下降趋势。如序列 [4,2,3,1]即为「下降摆动序列」。
		- 3、特别地，对于长度为 1 的序列，它既是「上升摆动序列」，也是「下降摆动序列」。
		- 4、序列中的某个元素被称为「峰」，当且仅当该元素两侧的相邻元素均小于它。如序列 [1,3,2,4] 中，3 就是一个「峰」。
		- 5、序列中的某个元素被称为「谷」，当且仅当该元素两侧的相邻元素均大于它。如序列 [1,3,2,4]中，2 就是一个「谷」。
		- 6、特别地，对于位于序列两端的元素，只有一侧的相邻元素小于或大于它，我们也称其为「峰」或「谷」。如序列 [1,3,2,4] 中，1 也是一个「谷」，444 也是一个「峰」。
		- 7.因为一段相邻的相同元素中我们最多只能选择其中的一个，所以我们可以忽略相邻的相同元素。现在我们假定序列中任意两个相邻元素都不相同，即要么左侧大于右侧，要么右侧大于左侧。对于序列中既非「峰」也非「谷」的元素，我们称其为「过渡元素」。如序列 [1,2,3,4]中，2 和 3 都是「过渡元素」。
		-  只需要统计该序列中「峰」与「谷」的数量即可
- 袁老师点评
	- 峰和谷的思路很好，只需要数峰谷的数量，这样就将一个纯数据的问题转换成为了一个简单的画图计数问题
	- 更加形象，理解起来更简单
	- 相当于把问题转换，最长子序列问题转换成找峰谷得问题
---
- LeetCode968监控二叉树:匡俊桦同学
	- 找到重点，确定数据结构和算法
		- 1、输入结构为一个二叉树，即递归型结构
		- 2、安装的摄像头其实就是标记二叉树节点
		- 3、标记的二叉树节点摄像头范围为周围1圈(r<=1)
		- 4、为了让监控的节点数最多，那么最好是摄像头周围都有节点，也就是说监控节点最好不是叶子节点 可以使用先序或后序遍历
		- 5、节点状态可以分为三类，一是未覆盖，标记0，二是摄像头，标记1，三是已覆盖，标记2
	- 方法一：递归法
		- 从根节点自上而下进行递归，通过当前节点状态推举出孩子节点的状态
		- 利用二叉树的递归结构，通过自上而下的递归遍历，最终得到自下而上的结果，我们取每次返回摄像头数目的最小值相加即可
		- 根节点root 根节点状态可以分为 ：
			- root已有摄像头 自己监控自己
				- 1.1左右孩子都没有摄像头，被root监控；
				- 1.2左孩子有摄像头，右孩子无；
				- 1.3左孩子无，右孩子有摄像头
			- root没有摄像头，被自己儿子监控
				- 3.1 左右孩子都有摄像头，自己监控自己
				- 3.2 左孩子有摄像头，自己监控自己，右孩子没有摄像头，被其儿子监控
				- 3.3左孩子没有摄像头，被其儿子监控，右孩子有摄像头，自己监控自己
	- 方法二：贪心算法
		- 首先空节点算作已覆盖的情况，从叶子节点开始向上遍历，通过该叶子节点的状态分析出当前节点的状态应该是什么 ，分析出四种情况
			- 1、左右节点都有覆盖，父节点状态标记为未覆盖
			- 2、左右节点至少有一个无覆盖的情况，父节点状态标记为摄像头，更新摄像头数量
				- left == 0 && right == 0 左右节点无覆盖
				- left == 1 && right == 0 左节点有摄像头，右节点无覆盖
				- left == 0 && right == 1 左节点无覆盖，右节点摄像头
				- left == 0 && right == 2 左节点无覆盖，右节点覆盖
				- left == 2 && right == 0 左节点覆盖，右节点无覆盖
			- 3、左右节点至少有一个有摄像头，父节点状态标记为已覆盖
				- left == 1 && right == 2 左节点有摄像头，右节点有覆盖
				- left == 2 && right == 1 左节点有覆盖，右节点有摄像头
				- left == 1 && right == 1 左右节点都有摄像头
			- 4、头结点没有覆盖，更新摄像头数量
- 袁老师点评
	- 贪心算法要考虑局部最优达到全局最优，摄像头尽可能覆盖最多的节点
	- 本题是等权，只需要覆盖节点的数量，如果题目设置成加权则难处理
	- 思路、代码质量很高，我感觉收获很大
	- 讲得很有条理，可视化，有分析过程而且分析得有头有脸，大家提升很大
	- 此次培训，分析问题的能力，思路转化为代码的能力有很大提升，有科研的感觉了，效果很好
