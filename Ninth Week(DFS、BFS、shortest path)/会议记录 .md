## 开场白
- 各位老师、同学，大家好！
- 欢迎来到本周题解会议。我是本周的组长匡俊桦。
- 本次会议的主题是图的常用算法DFS、BFS以及最短路径算法，通过本周的三个有趣例题可以让我们了解到图的定义(例如顶点、有向无向边、带权边等）、邻接表和邻接矩阵的定义，以及DFS、BFS、最短路径的应用场景。
## DFS
- DFS顾名思义是深度优先搜索，与树的先序遍历类似，即利用栈原理即递归来实现向深处搜索，往往用于图的连通性求解或者图的条件搜索问题上，其精髓为深处递归以及碰壁回溯。
## BFS
- BFS顾名思义是广度优先搜索，与树的层序遍历类似，即利用队列原理即将附近的节点依次加入队列，每次出队进行处理，往往用于层序遍历、求解图的无权最短路径问题和网格题。
## 最短路径
- 最短路径算法可以分为迪杰斯特拉和弗洛依达算法，
	- 其中Dijkstra算法是贪心的BFS版本，过程是操作顶点，把顶点的集合`V`分成两组，一个是已经求出最短路径的顶点集合S，一个是没有确定最短路径的顶点集合T，每次从没有确定的顶点集合T中找到最短路径的顶点加入S，适合于非负权图的单源最短路径；
	- Floyd又称之为插点法，是利用动态规划的在带权图中寻找多源最短路径的算法，但与前者不同的是过程是操作边，把图的边集合分为两组，与前者类似，一组为已求出最短路径的边集合S，一组为未求出最短路径的边集合T，每次从T中找到最短路径的边加入S。
## 接下来，我将为您介绍本周的题解者：
- [营梦曦同学]：[讲解207题] 首先是由营梦曦同学讲解207题这道使用DFS来求解给定的课程表是否合理的问题，通过将课程直接的先决条件变成有向图则可以转换为求解图中是否能不含环且全部遍历的问题
- [匡俊桦同学]：[讲解529题] 第二个由匡俊桦同学讲解529这道使用BFS模拟我们的经典扫雷游戏的游戏过程的题目，通过广度优先遍历来一层层试探前方是否有雷。
- [李勃朝同学]：[讲解743题] 第三个由李勃朝同学讲解743这道大家日常中比较关注的网络延迟的问题，我们都知道网络在主机之间传播是有延迟时间的，那么当某个主机发起广播时，怎么知道其它主机是否接收到了呢？我们可以利用最短路径算法求解出当前主机到其它主机的最短路径，如果存在不能传播到的主机，则延迟无限长，即无法到达，如果都能传播到，则取最短路径中的最大值为网络延迟时间即可。

---
- LeetCode207课程表是否有效:营梦曦同学  
	- 介绍图的定义，分析有向图和无向图两种类型的区别
	- 方法一：深度优先搜索（DFS）
		- 1.根据题目给出的课程依赖关系将其转化成为图的邻接表，邻接表可能存在三种状态，未被搜索、搜索中、搜索完成，定义一个变量标识节点状态，判断图中是否有环路
		- 2.对节点进行深度优先搜索，标记当前搜索节点的状态为1，然后遍历该节点相邻节点adj_node
			- (1).若 adj_node 的状态为[未被搜索]，则对 adj_node 同样执行DFS；
			- (2).若 adj_node 的状态为[搜索中]，则表示有节点在该次DFS中被第二次访问到，即有环路存在，则更改标识环路状态变量的值；
			- (3).若 adj_node 的状态为[搜索完成]，则表示当前节点已经在其他节点的DFS中被访问完成过了，不需要再次搜索；
		- 3.在整个深度优先搜索的过程结束后，就可以根据标识环路状态变量的值来判断图中是否有环路存在。
	- 方法二：广度优先搜索（BFS）
		- 1.根据题目给出的课程依赖关系，构建邻接表、节点的入度数组；
		- 2.选取入度为 0 的节点，使它对应的邻接节点的入度 -1（即“删除”入度为0的节点的关联边）；
		- 3.继续找出入度为0的节点，并重复2中的操作直至图中所有的节点的入度都为0，则表示图中不存在环路，否则若还存在有入度不为0的节点则表示图中存在环路。
- 匡俊桦点评
	- 准备得很充分，讲得也很清楚，特别是三种状态分别用了三种不同颜色进行了标记，并且使用了动画进行演示，非常直观易懂。
	- 深度优先的本质是先递归后回溯，将所有节点分为三种状态，往深度方向搜索，搜完后还会回来，通过动画把深度遍历的过程展现出来了。
	- 广度优先搜索思路更清晰些，更简单些，只需要依次删除边则可以得到想要的结果，这说明了DFS和BFS在解决问题上是有共同点的，他们之间可以互通。
---
- LeetCode529模拟扫雷游戏:匡俊桦同学   
	- 有两种情况需要判断，一是附近有地雷，则需要标记数量且不能继续递归揭露；二是附近没地雷且当前没挖过，则挖开当前位置并向周围递归揭露，最终返回修改后的数组
	- 方法一：广度优先搜索（BFS）
		- 如果挖到地雷则修改字符为“X”，返回二维数组
		- 利用队列来存储当前遍历元素的周围满足递归遍历条件的元素(即未翻开且周围无雷的元素)
		- 初始化进队元素为click，遍历之前初始化一个计算地雷数量的变量，之后按照顺时针从正上方开始遍历当前元素的周围相邻元素xy，
		- 如果周围有雷，则当前位置XY的周围雷数+1，并且当前遍历的周围元素xy不能进队，将周围全部遍历完之后，将当前元素覆盖为雷数；
		- 如果周围没有雷，则当前位置XY为以翻开的空白点E，并且如果当前遍历元素xy没有翻开，则翻开此位置xy，并且将元素进队，作为可以递归遍历的对象
	- 方法二：深度优先搜索（DFS）
		- 使用深度优先搜索方法，与BFS类似，但不同在递归遍历时先一直搜寻直到边界之后再按照顺时针进行遍历周围
		- 先初始化一个雷数变量，和BFS一样，如果周围有雷则雷数+1，判断XY周围是否有雷，如果有雷则将当前位置覆盖为雷数，并且进行回溯；如果没有雷，则将当前XY翻开为B，递归遍历周围
---
- LeetCode743如何求网络延迟时间:李勃朝同学
	- Dijkstra算法，每次找到离源点最近的一个点，以该点为中心，更新源点到其他源点的最短路径，贪心的思想。
	- 方法一：Dijkstra
		- 存储各个边权，代码中使用了邻接矩阵 `g[i][j]` 存储从点 i 到点 j 的距离。若两点之间没有给出有向边，则初始化为 inf。
		- 记录所有点到源点的最短距离，使用 dist[i] 数组存储源点到点 i 的最短距离，初始值全部设为 inf （源点k设为0）
		- 使用 used[i] 数组存储（标记）某一节点是否已确定了最短路，若已确定最短距离，则值为 true，否则值为 false。
	- 方法二：堆优化Dijkstra
		- 通过小根堆优化未确定节点中距离起点最近的点
		- 由于堆存储边，而边多于节点，所以效果不明显
- 匡俊桦点评
	- 准备得很充分，不是第一次遇到堆这个数据结构了，堆给我们留下了很深刻的求前K个有序序列问题，包括这里也是使用堆来求一个最小值，通过数据结构进一步优化算法，这是非常好的思路。
	- Dijkstra解决单源点到其他节点的最短距离，这道题用一个数组存储了源点到其他点的距离，然后用Dijkstra算法更新数组，最终输入数组中最大值（非inf），作为最大的网络延迟，如果存在inf则返回-1
	- Floyd也能实现点到点的最短距离，也能达到同样的效果，但它需要输入源节点，目标节点，然后给出最短路径，时间复杂度是$O(n^3)$
---
## 匡俊桦同学总结
- 图的定义，顶点、边（有向、无向、权值）
- 存在有向有环图，有向无环图
- 图的实现方式，邻接矩阵、邻接表
- 遍历方式：深度优先搜索、广度优先搜索
- 最短路径：Dijkstra算法、Floyd算法
```c
//深度优先搜索框架
void dfs(int x)//关于传入参数问题，根据题意而定，看在题目运行的过程中，哪些是在变得
{
    if(满足输出条件)
    {
        输出解;
        return ;
    }
    if(目前已经没有必要进行下去的条件){
        return ;
    }//剪枝操作
    //如果传入的条件，还需要继续搜下去，分析每一种情况后面跟哪些情况，然后循环，每个情况（注意前提：得符合题意）都深搜一下
     for(int i=1;i<=每种情况数;i++)
            if(满足进一步搜索条件)//判断是否合理
            {
                为进一步搜索所需要的状态打上标记;//是需要的状态
                dfs(t+1);
                恢复到打标记前的状态;//也就是说的{回溯一步}
            }
    }
}
```