## 开场白
- 各位老师，同学大家好！
- 欢迎来到本周题解会议。我是本周的组长匡俊桦。
- 本次会议的主题是常用排序算法，本周介绍的排序算法分别为快速排序、堆排序、桶排序，通过本周的三个例题，我们可以了解到快速排序如何解决退化问题、堆排序过程、桶排序过程，以及它们三者的适用场景是什么。
## 接下来，我将为您介绍本周的题解者：
- [黄添洪同学]：[讲解912题] 首先是由黄添洪同学讲解这道利用快速排序解决最为常用的排序，但与普通的快速排序不同的是，native的快排方法无法通过某些样例，因为快排存在基准点的选择问题，当基准点选择不好时，时间复杂度会非常高，因此需要进行优化才可以解决此快排退化问题。
- [甘英华同学]：[讲解215题] 第二个由甘英华同学讲解这道我们曾经遇到过的经典TopK问题，这里要你只排序出前K个最大元素，并且使用O(n)的时间复杂度来实现，因此我们可以使用之前所是使用的堆排序算法来进行求解，或者使用快速排序的基准点到达第n-K+1位置时返回已排序的数组也可以实现。
- [金思铭同学]：[讲解164题] 第三个由金思铭同学讲解这道在O(n)的时间和空间复杂度下求解排序之后的数组中相邻元素的最大间距问题，我们首先得知道所要求的情况下只有计数排序、桶排序、基数排序可以达到该要求，其中计数排序是桶排序的特殊情况，即桶里只有一个元素，其适合于数据较为集中的情况；桶排序适合于最大最小值相差较大的情况并且数据分布均匀；基数排序是桶排序的扩展，适用于字符串排序，或者需要根据多个条件进行排序的场景。因此我们这里使用桶排序，因为每个桶中可以放多个元素，即我们排序之后只需要将当前桶的最小值减去前一个桶的最大值即可计算出差值。
---
- LeetCode912快速排序(解决快排退化问题):黄添洪同学  
	- 算法步骤
		- 选择一个基准元素（pivot），将数组分成左右两部分。
		- 左部分包含小于等于基准的元素，右部分包含大于基准的元素。
		- 对左右两部分递归地应用快速排序算法。
		- 合并排序后的左部分、基准和右部分。
	- 时间复杂度分析
		- 最好情况：O(nlog₂n)
		- 平均情况：O(nlog₂n)
		- 最坏情况：O( n² ) （当基准选取不合适时）
		- 快速排序通常比其他排序算法更快，因为它具有更好的缓存性能
	- 优化基准元素
		- 取中间值作为基准元素
		- 随机取基准元素
	- 总结
		- 快速排序是一种高效的排序算法，适用于各种规模的数据集。
		- 使用分治法原则，通过选取基准元素不断分割和排序子数组。
		- 在实际应用中，需要注意基准的选择以及对小数组的处理。
- 匡俊桦点评
	- 基准值不能随便选，如果本身就是基本有序，而基准值又总是选择最小值，那么就退化成最坏情况
	- 如果数据集合全部为一个数，比如全部为1，那么要考虑快排退化的问题，加条件，加判断
---
- LeetCode215堆排序TopK问题:甘英华同学   
	- 方法一：优化版的快速排序——升序
		- 寻找第k大的元素，也就是寻找升序排序后索引为len(nums)-k的数
		- step1:选择最左侧的元素为基准数pivot
		- step2:当left < right时，right向左滑动，直到nums[right]小于pivot，left向右滑动，直到nums[left]大于pivot
		-  step3:交换left和right的值，重复step2
		-  step4:left == right时，交换nums[left]和pivot(即nums[low])的值
		-  step5:比较基准数的索引和len(nums)-k的大小，若等于则直接返回该元素，若大于则排序左子数组，若小于则排序右子数组
	- 方法二：堆排序
		- 堆：一棵完全二叉树的结构，并且满足堆积的性质：每个节点(叶节点除外)的值都大于等于(或都小于等于)它的子节点
			- 大根堆：一颗完全的二叉树，满足任意节点都大于等于其孩子节点，`nums[i]>=nums[2i+1]&&nums>=nums[2i+2]`
			- 小根堆：一颗完全的二叉树，满足任意节点都小于等于其孩子节点，`nums[i]<=nums[2i+1]&&nums[i]<=nums[2i+2]`
		- 堆排序 通常包含以下几个基本步骤：
			- 建堆：将待排序的数组初始化为大根堆。此时，堆顶的元素（即根节点）即为整个数组中的最大值。从最后一个「非叶子节点」为根节点的子树出发，从右往左、从下往上进行调整操作。
			- 交换和调整：将堆顶元素与末尾元素进行交换，此时末尾即为最大值。除去末尾元素后，将其他 n−1个元素重新构造成一个大根堆，如此便可得到原数组 n个元素中的次大值。
			- 重复步骤二，直至堆中仅剩一个元素，如此便可得到一个有序序列了。
			- 返回有序序列中第k大元素
	- 方法二优化：堆排序
		- 对前k个元素排序后停止继续排序，输出第k个元素
- 匡俊桦点评
	- 题目要求是线性时间复杂度，但是内置函数，堆排序都能通过，因此其实这道题没有特别给定一个线性时间复杂度才能过得样例
	- 快速排序通过基准值与n-k下标比较得到第k大的元素
	- 堆排序可以得到前k个有序序列，也可以得到第k大元素，而如果只需要得到第k大元素，那么排好前k个元素就可以结束了，因此这道题使用快速排序也是一个非常好的思路，相对而言堆排序适合于前k的元素的排序，即我们不仅要第k个元素，也要其它的，这个时候就需要堆排序了。
---
- LeetCode164(最大间距):金思铭同学
	- 基数排序
		- 建立二维数组，行数为10的空数组
		- 遍历数组并根据个位数放入二维数组对应的行
		- 遍历二维数组，并根据十位数放入二维数组对应的行
		- 重复上述过程，直到根据最高位放入二维数组对应的行
		- 遍历二维数组，将二维数组元素放入一维数组中，得到有序的一维数组
	- 遍历一维数组，得到相邻元素间距最大值
- 匡俊桦点评
	- 这道题本来是想着给大家介绍桶排序，但是金思铭同学介绍的基数排序其实也可以，因为基数排序是桶排序的扩展，基数排序将桶排序的桶分布规则改变为动态的，每次选择一个位来进行排序，最终得到有序序列。
	- 桶排序又叫箱排序，是计数排序的升级版，它的工作原理是将数组分到有限数量的桶里，然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。
---
## 总结
- 题目总结
	- 快速排序 912
		- 快速排序是一个较为常用的排序算法，在大多数情况下都是适用的，尤其在数据量大的时候性能优越性更加明显。但是在必要的时候，需要考虑下优化以提高其在最坏情况下的性能。
	- 堆排序 215
		- 堆排序(Heapsort)是指利用堆积树(完全二叉树)（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。
		- 堆排序先按从上到下、从左到右的顺序将待排序列表中的元素构造成一棵完全二叉树，然后对完全二叉树进行调整，使其满足堆的性质：每个节点(叶节点除外)的值都大于等于(或都小于等于)它的子节点。构建出堆后，将堆顶与堆尾进行交换，然后将堆尾从堆中取出来，取出来的数据就是最大(或最小)的数据。重复构建堆并将堆顶和堆尾进行交换，取出堆尾的数据，直到堆中的数据全部被取出，列表排序完成。
		- 堆排序在建立堆和调整堆的过程中会产生比较大的开销，在元素少的时候并不适用。但是，在元素比较多的情况下，还是不错的一个选择。尤其是在解决诸如“前n大的数”一类问题时，几乎是首选算法。
	- 桶排序(计数排序-->桶排序-->基数排序) 164
		- 桶排序又叫箱排序，是计数排序的升级版，它的工作原理是将数组分到有限数量的桶子里，然后对每个桶子再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序），最后将各个桶中的数据有序的合并起来。
		- 计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。网络中很多博文写的桶排序实际上都是计数排序，并非标准的桶排序，要注意辨别。
- 排序算法-来自匡俊桦同学
	- 非线性时间比较类排序
		- 交换排序
			- 冒泡排序
			- 快速排序
		- 插入排序
			- 简单插入排序
			- 希尔排序
		- 选择排序
			- 简单选择排序
			- 堆排序
		- 归并排序
			- 二路归并排序
			- 多路归并排序
	- 线性时间非比较类排序
		- 计数排序
		- 桶排序
		- 基数排序
- 算法复杂度-来自甘英华同学和网络

![排序算法](Lecturer_folder\甘英华-215\排序算法.png)