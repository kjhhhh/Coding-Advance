## 开场白
- 各位老师，各位同学，早上好！
- 欢迎来到本周题解会议。我是本周的组长匡俊桦。
- 本次会议的主题是单调队列和单调栈，首先通过此次会议我们可以知道单调队列和单调栈是一个什么样的数据结构，以及单调栈一般应用场景为从数组中找到左右两边第一个比某元素大的数或者比某元素第一个小的数，而且时间复杂度为O(N)，**单调栈的本质是空间换时间**，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是整个数组只需要遍历一次。如果求一个元素右边第一个更大元素，单调栈就是从栈底到栈顶递减的，也就是递减栈，如果求一个元素右边第一个更小元素，单调栈就是递增的，也就是递增栈。
- 单调队列往往是在双端队列上进行实现的，在单调队列的应用上，它经常用来解决定长连续子区间的最值问题，例如滑动窗口RMQ。优先队列与单调队列不同，一般采用二叉堆来实现，由于优先队列的性质，它常常被用来解决多次维护最大最小值的问题，例如topK问题。
-  [陈慧同学]：[讲解53题] 首先是上周二分专题的回顾题目 由陈慧同学来介绍53题这道求一维最大连续子数组的和不超过k的子数组问题 是上周袁老师讲解的二维子区间的和不超过k的降维题目
- [黄添洪同学]：[讲解739题]  之后进入我们本周的单调栈和单调队列专题，第一个由黄添洪同学来介绍739这个典型的使用单调栈求解序列中某元素右边的第一个更大值
- [颜勇君同学]：[讲解503题] 第二个由颜勇君同学来介绍503这道变式739题，等于是将739题目的序列变成一个循环序列，循环寻找某元素右边的第一个更大值
- [夏性权同学]：[讲解42题] 第三个由夏性权同学介绍42题这道接雨水题目，这道题是一个双向寻找某元素左右第一个更大值问题，因为找到左右第一个更大的元素之后，就可以围起来接雨水，此时使用宽度(为1)✖高度差(Min(lheight,rheight)-height)
- [李勃朝同学]：[讲解239题] 第四个由李勃朝同学来介绍239题，这道题是单调队列的经典应用，我们都学过TCP协议，其中的流量控制就是使用了我们经典的滑动窗口，可以有效的防止消息溢出问题的发生，而我们这道题就是求一个滑动窗口内的最大值问题
- [许雅婷同学]：[讲解84题] 第五个由许雅婷同学来介绍84题，这道题和42题类似，只不过接雨水是凹进去，求的是左右第一个更大的柱子，而本题则是凸出来，找左右第一个更小的柱子。
---
- LeetCode53:陈慧同学 
  - 读题，指出本题采用动态规划的思想
  - 负数  +  负数 一定会变小，负数+正数 它这个和也会比这个正数要小
  - 正数  +  正数  变得更大 ，我们采用sum记录和，并且每次记录之后都与max进行比较，保证max一直是当前最大的和
  - 正数+ 负数 （>0）依旧当作正数来处理，因为sum没有变成负数的时候就依旧有变大的可能
  - 正数+负数（<0） 这个时候我们就要将sum重新初始化为0
  - 当前如果出现了sum为负数的情况，这个子数组就不会再大于之前的最大和了，我们就可以另寻子数组了。
  - 每次进行计算就要将sum与max进行比较，这样保证我们的max记录的一直都是当前的最大值
- 匡俊桦点评
	- 思路很清晰，序列分成左和右，如果左边负数+右边负数会变小，就算左边负数+右边正数的和依然比当前正数要小，应该舍弃左边子区间和，将区间和重置为0，重新开始寻找新的最大子区间
---
- LeetCode739:黄添洪同学 
	- 读题，讲解示例
	- 方法一：暴力解法 双层循环遍历
		- 遍历temperatures，然后从当前元素的下一个元素开始进行遍历，找到下一个更大的元素，如果找到则将大下标减去小下标并存入answer
	- 方法二：单调栈
		- 通过倒三角形比喻递减栈示例演示算法的过程
		- 创建递减栈，栈存储温度下标，遍历temperatures，如果当前元素大于栈顶元素对应的温度，那么就将栈顶元素出栈，并将下标差作为出栈元素的下一个更大温度
- 匡俊桦点评
	- 讲得很多清晰，图形画得很好
	- 双循环，从右往左循环，考虑通过hashtable加速
	- 从左往右找通过递减栈，找到下一个更大温度
---
- LeetCode503:颜勇君同学 
	- 方法一：暴力解法 双循环遍历
		- 将数组复制并将双倍长度的数组存入新数组中
		- 遍历新数组，第二层循环向后查找下一个更大的值
	- 方法二：单调栈
		- 将数组复制并将双倍长度的数组存入新数组中
		- 通过递减栈，存储元素下标，遍历新数组，如果当前元素大于栈顶元素对应的值，那么就将栈顶元素出栈，并当前元素值作为出栈元素的下一个更大数，存入字典中
		- 遍历原数组，在字典中查找下一个更大数
	- 方法二优化：单调栈
		- 通过取余的方式免去复制数组，免去字典等额外空间
- 匡俊桦点评
	- 讲得很好，还可以现场改良
	- 将数组扩大一倍，这个思路挺好的，比较好处理
	- 上一道题的变式，现在给出了循环数组，一般单调栈用于查询两侧的第一个较大/较小元素，而循环数组的加入给题目带来了更大灵活度
---
- LeetCode42:夏性权同学 
	- 方法一：按层计算
		- 由底向顶一层一层的遍历，得到每一层可以接住的雨水，最后所有层次所接到的雨水之和即为答案。
		- 永远只遍历底层，并且遍历区间为第一个不为0元素到最后一个不为0元素
		- 在进行遍历的时候，如果当前位置元素高度不为0，则当前元素高度减一个单位，否则就代表当前位置可以接住雨水，将要返回的答案自增1即可。直到遍历完所有层次即可。
	- 方法二：双指针法
		- 先计算装满雨水之前柱状图的面积，再计算装满水之后柱状图的面积，所接的雨水即为两面积的差。
		- 利用双指针i，j分别指向第一个元素和最后一个元素，定义一个flag=0
		- 随后开始遍历，比较height[i]与height[j]的大小，如果min(height[i],height[j])<flag，则使min(height[i],height[j])=flag,随后更新flag=min(height[i],height[j])，并使指向min(height[i],height[j])的指针自增或自减1，直到i>=j为止。
- 匡俊桦点评
	- 双指针的解法很清晰，也挺快的
	- 从某个柱子开始，从左边和右边找到第一个比他大的，围起来才可以接雨水
	- 可以尝试单调栈的解法，下一周可以尝试单调栈的解法
---
- LeetCode239:李勃朝同学 
	- 方法一：双循环
		- 第一层循环遍历前n-k+1个元素
		- 第二层循环遍历窗口区间并获得最大值
	- 方法二：优先队列
		- 建立大根堆并把前k个元素存入队列中
		- 遍历后n-k个元素，将当前元素入队
			- 如果堆顶元素不在滑动窗口范围内，则将堆顶元素出堆，把调整过的堆顶元素作为当前滑动窗口的最大值
			- 如果堆顶元素在滑动窗口的范围内，那么堆顶元素就是滑动窗口的最大值
	- 方法三：单调队列
		- 建立双端队列，将前k个元素存入队列中，队列中元素对应的值是递减的
		- 遍历后n-k个元素，将当前元素入队
			- 如果队头元素不在滑动窗口范围内，则将队头元素出队，直到找到在滑动窗口的队头元素，也就是当前滑动窗口的最大值
			- 如果队头元素在滑动窗口范围内，直接队头元素就是滑动窗口的最大值
- 匡俊桦点评
	- tcp协议通过滑动窗口来控制流量，判断是否丢帧
	- 和topk思路有点像，给了一个数组，只是固定了一个窗口，会滑动
	- 优先队列和单调队列有区别，优先队列每次进出元素时都会调用堆排序算法实现内部有序，其底层实现是堆数据结构，而单调栈则是使用限制进出元素来控制单调性，其底层实现是双端队列数据结构
---
- LeetCode84:许雅婷同学
	- 审题，基本思路是找到当前元素左边第一小元素、右边第一小元素后，计算出宽度。然后以当前元素值为标准高度，计算面积。
	- 方法一：双循环
		- 1、遍历数组
		- 2、依次寻找当前元素左边第一个最小元素下标min_left、右边第一个最小元素下标min_right
		- 3、计算标准高度为heights[i]的矩形宽度min_right-min-left-1
		- 4、计算矩形面积area，将area与当前最大面积largestArea比较，若area>largestArea，则替换；
		- 5、返回最大面积largestArea。
	- 方法二：双指针
		- 1、遍历数组
		- 2、找出每个元素左边第一小元素，将其下标存入数组minLeft;
		- 3、找出每个元素右边第一小元素，将其下标存入数组minRight;
		- 4、遍历数组，依次计算标准高度为heights[i]的矩形宽度min_right-min-left-1，同时计算矩形面积area，将area与当前最大面积largestArea比较，若area>largestArea，则替换；
		- 5、返回最大面积largestArea。
	- 方法三：单调栈
		- 1、遍历数组，定义栈，并将0入栈
			- 若栈顶元素<当前元素，当前元素入栈；
			- 若栈顶元素=当前元素，栈顶元素出栈，当前元素入栈；
			- 若栈顶元素>当前元素
				- 栈不为空且栈顶元素>当前元素，用mid暂存栈顶元素后，将其出栈。栈不为空时，当前元素为mid右边的第一小元素，栈顶元素为mid左边的第一小元素。计算标准高度为heights[i]的矩形宽度min_right-min-left-1。计算矩形面积area，将area与当前最大面积largestArea比较，若area>largestArea，则替换；
				- 将当前元素入栈。
		- 2、返回最大面积largestArea。
- 匡俊桦点评
	- 讲得很清晰，正常的思路是双循环，先尝试一下，发现问题然后又想其他方法
	- 类似于接雨水一层一层的算，只不过接雨水是一层一层算凹陷，这道题一层一层算凸起
	- 递增栈，递减栈定义统一，递增栈一般寻找下一个更小元素，递减栈一般寻找下一个更大元素
	- 动态规划的思想，去左边或右边去找现有的更小元素，可以更快一些
	- 符合本周的主题，准备得很充分

---
