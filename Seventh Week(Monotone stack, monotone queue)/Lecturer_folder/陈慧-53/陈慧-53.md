# 思路分析

题目本身不难，但是限制了时间复杂度为 O(N)，就需要多思考下，看如何能优化时间复杂度。

## 暴力枚举法 O(N^3)

首先，从最暴力的解法入手——枚举。即枚举所有的数组下标 (i, j)，其中 i <= j。则连续子数组的和为 sum(nums[0:j]) - sum(nums[0: i - 1])。依次计算出所有的可能的子数组的和，自然也就得到最大的和。

那上面这种暴力破解的方法，时间复杂度是多少呢？是 O(N^3)，因为两层 for 循环，每个循环处理中，又计算了子数组的和，所以叠加起来实际上是三层 for 循环。

## 前缀和优化 O(N^2)

既然复杂度太高，就要想方法区去降维，把三层 for 循环，降低到一层循环。换句话讲，就是要把循环处理中的冗余计算，给精简掉。

其实从上面的推导中，不难发现，连续子数组的和，实际上是两个「前缀和」相减。即

```python
sum(i, j) = pre_sum(j) - pre_sum(i - 1)
```


因此，如果提前计算好前缀和，那么计算子数组元素之和的第三层 for 循环就可以省去。即时间复杂度降低到 O(N^2)

## 前缀和一次遍历 O(N)

那如何再优化掉一层 for 循环呢？

再来对前缀和的思路进行分析，题目要求找到子数组的最大和，那么在遍历每个前缀和时，是否必须进行两层 for 循环呢，只用一层 for 循环，是否可以？

沿着这个思路继续推导。在对前缀和做遍历的过程中，如果记录当前所遍历到的最小的前缀和，就能够确保最终的结果一定是以该最小的前缀和作为左边界。则在一次遍历中，必然可以计算得到每个右边界，和位于右边界之前的最小前缀和的左边界的差值（即子数组元素和），因此可以做到一次遍历，求解子数组的最大和。

分析到这，前缀和的解法思路已经很清晰了。代码参考如下——

前缀和解法

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        ans, sum, minimum = nums[0], 0, 0
        for num in nums:
            sum += num
            ans = max(ans, sum - minimum)
            minimum = min(minimum, sum)
        return ans
```


时间复杂度：O(N)
空间复杂度：O(1)

